
==================== FINAL INTERFACE ====================
2016-09-25 00:57:49.059175 UTC

interface main@main:Tetris 8001
  interface hash: 4429e3256f4318832e02c9d9e5d56ddf
  ABI hash: ebf4afc44e3bad5bbd40d7f8a271f4d6
  export-list hash: ecf5372ba323fcd9af619ae01e63ac2c
  orphan hash: 360eb72b2109b71f5ecd6daec4a9cf86
  flag hash: 17a73781f56f518d479c11649db562e9
  sig of: Nothing
  used TH splices: False
  where
exports:
  Tetris.applyOffset
  Tetris.applyOffsets
  Tetris.rotateClockwise
  Tetris.Grid{Tetris.Grid gridData gridSize}
  Tetris.Point{Tetris.Point x y}
  Tetris.PointOffset{Tetris.PointOffset xOffset yOffset}
  Tetris.Tetris{Tetris.Tetris tetrisPiece tetrisType}
  Tetris.TetrisPiece{Tetris.TetrisPiece offsets origin}
  Tetris.TetrisType{Tetris.Negative Tetris.Positive}
module dependencies:
package dependencies: base-4.9.0.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.0.0:GHC.Base base-4.9.0.0:GHC.Float
family instance modules: base-4.9.0.0:Control.Applicative
                         base-4.9.0.0:Data.Either base-4.9.0.0:Data.Functor.Const
                         base-4.9.0.0:Data.Monoid base-4.9.0.0:Data.Type.Equality
                         base-4.9.0.0:GHC.Generics base-4.9.0.0:GHC.IO.Exception
                         base-4.9.0.0:GHC.TypeLits
import  -/  base-4.9.0.0:Data.Foldable 8aeb682f6c74f97fcf0ace0d608a43ea
import  -/  base-4.9.0.0:GHC.Base 8ed3be81c0707b322f975a84ae1bb816
import  -/  base-4.9.0.0:GHC.Num 48f506a8f4ecf06285d0a0706594dcc0
import  -/  base-4.9.0.0:GHC.Show 952347a6ab730bcb25c0854d8bc6ca51
import  -/  base-4.9.0.0:Prelude b9bddb97799837fe67a8d00939a5b6c3
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
17bd4a3ec42b8635bff3b3f9cd156850
  $fEqGrid :: GHC.Classes.Eq a => GHC.Classes.Eq (Tetris.Grid a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Tetris.Grid a)
                  (Tetris.$fEqGrid_$c== @ a $dEq)
                  (Tetris.$fEqGrid_$c/= @ a $dEq) -}
17bd4a3ec42b8635bff3b3f9cd156850
  $fEqGrid_$c/= ::
    GHC.Classes.Eq a =>
    Tetris.Grid a -> Tetris.Grid a -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S(S(S)L),1*U(1*U(U),1*U)><S(S(S)L),1*U(1*U(U),1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (w1 :: Tetris.Grid a)
                   (w2 :: Tetris.Grid a) ->
                 case w1 of ww { Tetris.Grid ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w2 of ww5 { Tetris.Grid ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Tetris.$w$c/= @ a w ww4 ww2 ww9 ww7 } } } }) -}
17bd4a3ec42b8635bff3b3f9cd156850
  $fEqGrid_$c== ::
    GHC.Classes.Eq a =>
    Tetris.Grid a -> Tetris.Grid a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>,
     Unfolding: (\ @ a ($dEq :: GHC.Classes.Eq a) ->
                 let {
                   $dEq1 :: GHC.Classes.Eq [a] = GHC.Classes.$fEq[] @ a $dEq
                 } in
                 \ (ds :: Tetris.Grid a) (ds1 :: Tetris.Grid a) ->
                 case ds of wild { Tetris.Grid a1 a2 ->
                 case ds1 of wild1 { Tetris.Grid b1 b2 ->
                 case a1 of wild2 { GHC.Types.I# x1 ->
                 case b1 of wild3 { GHC.Types.I# y1 ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# x1 y1) of wild4 {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> GHC.Classes.$fEq[]_$c== @ [a] $dEq1 a2 b2 } } } } }) -}
f013f53523c0c40072bf51e10a0b09e8
  $fEqGrid_$s$fEq[] :: GHC.Classes.Eq [GHC.Types.Bool]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ [GHC.Types.Bool]
                  (GHC.Classes.$fEq[]_$c== @ GHC.Types.Bool GHC.Classes.$fEqBool)
                  Tetris.$fEqGrid_$s$fEq[]_$c/= -}
9b19dbe3b896c149101ed7df85472da6
  $fEqGrid_$s$fEq[]_$c/= ::
    [GHC.Types.Bool] -> [GHC.Types.Bool] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x1 :: [GHC.Types.Bool]) (y1 :: [GHC.Types.Bool]) ->
                 GHC.Classes.not
                   (GHC.Classes.$fEq[]_$c==
                      @ GHC.Types.Bool
                      GHC.Classes.$fEqBool
                      x1
                      y1)) -}
85cd496138a5059b07114f34a9f8bbc6
  $fEqPoint :: GHC.Classes.Eq Tetris.Point
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tetris.Point Tetris.$fEqPoint_$c== Tetris.$fEqPoint_$c/= -}
85cd496138a5059b07114f34a9f8bbc6
  $fEqPoint_$c/= :: Tetris.Point -> Tetris.Point -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Tetris.Point) (w1 :: Tetris.Point) ->
                 case w of ww { Tetris.Point ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Tetris.Point ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Tetris.$w$c/=1 ww4 ww2 ww9 ww7 } } } }) -}
85cd496138a5059b07114f34a9f8bbc6
  $fEqPoint_$c== :: Tetris.Point -> Tetris.Point -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(S)L),1*U(1*U(U),1*U(U))><S(S(S)L),1*U(1*U(U),1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Tetris.Point) (w1 :: Tetris.Point) ->
                 case w of ww { Tetris.Point ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case w1 of ww5 { Tetris.Point ww6 ww7 ->
                 case ww6 of ww8 { GHC.Types.I# ww9 ->
                 Tetris.$w$c== ww4 ww2 ww9 ww7 } } } }) -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fEqTetris :: GHC.Classes.Eq Tetris.Tetris
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tetris.Tetris Tetris.$fEqTetris_$c== Tetris.$fEqTetris_$c/= -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fEqTetrisType :: GHC.Classes.Eq Tetris.TetrisType
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tetris.TetrisType
                  Tetris.$fEqTetrisType_$c==
                  Tetris.$fEqTetrisType_$c/= -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fEqTetrisType_$c/= ::
    Tetris.TetrisType -> Tetris.TetrisType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Tetris.TetrisType) (b :: Tetris.TetrisType) ->
                 case a of wild {
                   Tetris.Positive
                   -> case b of wild1 {
                        Tetris.Positive -> GHC.Types.False
                        Tetris.Negative -> GHC.Types.True }
                   Tetris.Negative
                   -> case b of wild1 {
                        Tetris.Positive -> GHC.Types.True
                        Tetris.Negative -> GHC.Types.False } }) -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fEqTetrisType_$c== ::
    Tetris.TetrisType -> Tetris.TetrisType -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Tetris.TetrisType) (ds1 :: Tetris.TetrisType) ->
                 case ds of wild {
                   Tetris.Positive
                   -> case ds1 of wild1 {
                        Tetris.Positive -> GHC.Types.True
                        Tetris.Negative -> GHC.Types.False }
                   Tetris.Negative
                   -> case ds1 of wild1 {
                        Tetris.Positive -> GHC.Types.False
                        Tetris.Negative -> GHC.Types.True } }) -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fEqTetris_$c/= :: Tetris.Tetris -> Tetris.Tetris -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(1*U(U),1*U))><S(SL),1*U(1*U,1*U(1*U(U),1*U))>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Tetris.Tetris) (b :: Tetris.Tetris) ->
                 case Tetris.$fEqTetris_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fEqTetris_$c== :: Tetris.Tetris -> Tetris.Tetris -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SL),1*U(1*U,1*U(1*U(U),1*U))><S(SL),1*U(1*U,1*U(1*U(U),1*U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Tetris.Tetris) (w1 :: Tetris.Tetris) ->
                 case w of ww { Tetris.Tetris ww1 ww2 ->
                 case w1 of ww3 { Tetris.Tetris ww4 ww5 ->
                 Tetris.$w$c==1 ww1 ww2 ww4 ww5 } }) -}
17bd4a3ec42b8635bff3b3f9cd156850
  $fShowGrid :: GHC.Show.Show a => GHC.Show.Show (Tetris.Grid a)
  DFunId
  {- Arity: 1, Strictness: <L,U(A,A,C(C1(U)))>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Tetris.Grid a)
                  (Tetris.$fShowGrid_$cshowsPrec @ a $dShow)
                  (Tetris.$fShowGrid_$cshow @ a $dShow)
                  (Tetris.$fShowGrid_$cshowList @ a $dShow) -}
81cc61d0936c3a90ced9f53159728779
  $fShowGrid1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
13fbdb6aa573c66888cdfedf4c6212f4
  $fShowGrid2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Grid {"#) -}
8fc0b4159ceb9922aa5f82930d60d8ae
  $fShowGrid3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
a68108b32839a0835fbd2ff88d7c87fe
  $fShowGrid4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "gridData = "#) -}
70c31890fdb10b8b9f866d7ab8907322
  $fShowGrid5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
5827ef3832c0f6c589cabcbfdda3a758
  $fShowGrid6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "gridSize = "#) -}
17bd4a3ec42b8635bff3b3f9cd156850
  $fShowGrid_$cshow ::
    GHC.Show.Show a => Tetris.Grid a -> GHC.Base.String
  {- Arity: 2,
     Strictness: <L,1*U(A,A,1*C(C1(U)))><S,1*U(1*U(U),1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x1 :: Tetris.Grid a) ->
                 Tetris.$fShowGrid_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
17bd4a3ec42b8635bff3b3f9cd156850
  $fShowGrid_$cshowList ::
    GHC.Show.Show a => [Tetris.Grid a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(A,A,C(C1(U)))><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Tetris.Grid a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Tetris.Grid a)
                   (Tetris.$fShowGrid_$cshowsPrec @ a $dShow Tetris.$fShowGrid1)
                   eta
                   eta1) -}
17bd4a3ec42b8635bff3b3f9cd156850
  $fShowGrid_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Tetris.Grid a -> GHC.Show.ShowS
  {- Arity: 4,
     Strictness: <L,1*U(A,A,1*C(C1(U)))><S(S),1*U(U)><S,1*U(1*U(U),1*U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Tetris.Grid a)
                   (w3 :: GHC.Base.String) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Tetris.Grid ww3 ww4 ->
                 Tetris.$w$cshowsPrec @ a w ww1 ww3 ww4 w3 } }) -}
85cd496138a5059b07114f34a9f8bbc6
  $fShowPoint :: GHC.Show.Show Tetris.Point
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tetris.Point
                  Tetris.$fShowPoint_$cshowsPrec
                  Tetris.$fShowPoint_$cshow
                  Tetris.$fShowPoint_$cshowList -}
85cd496138a5059b07114f34a9f8bbc6
  $fShowPoint1 :: Tetris.Point -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Tetris.Point) (w1 :: GHC.Base.String) ->
                 case w of ww { Tetris.Point ww1 ww2 ->
                 Tetris.$w$cshowsPrec1 0# ww1 ww2 w1 }) -}
b66f76a5cc8ecbc5a9bcc3d9fc7780e6
  $fShowPoint2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Point {"#) -}
47e89910cd5700af40e36c11a0fba103
  $fShowPoint3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "y = "#) -}
97a9897f545510dd534b61f8ca3b761c
  $fShowPoint4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "x = "#) -}
85cd496138a5059b07114f34a9f8bbc6
  $fShowPoint_$cshow :: Tetris.Point -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U),1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Tetris.Point) ->
                 Tetris.$fShowPoint_$cshowsPrec
                   GHC.Show.shows22
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
85cd496138a5059b07114f34a9f8bbc6
  $fShowPoint_$cshowList :: [Tetris.Point] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Tetris.Point
                   Tetris.$fShowPoint1) -}
85cd496138a5059b07114f34a9f8bbc6
  $fShowPoint_$cshowsPrec ::
    GHC.Types.Int -> Tetris.Point -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S(S),1*U(U)><S,1*U(1*U(U),1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Tetris.Point)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Tetris.Point ww3 ww4 ->
                 Tetris.$w$cshowsPrec1 ww1 ww3 ww4 w2 } }) -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fShowTetris :: GHC.Show.Show Tetris.Tetris
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tetris.Tetris
                  Tetris.$fShowTetris_$cshowsPrec
                  Tetris.$fShowTetris_$cshow
                  Tetris.$fShowTetris_$cshowList -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fShowTetris1 :: Tetris.Tetris -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ (w :: Tetris.Tetris) (w1 :: GHC.Base.String) ->
                 case w of ww { Tetris.Tetris ww1 ww2 ->
                 Tetris.$w$cshowsPrec2 0# ww1 ww2 w1 }) -}
bc46864653964d6d1f8fe4135784dfe4
  $fShowTetris2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Tetris {"#) -}
a64ea3aa12c5d38db427af5a45524b94
  $fShowTetris3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Negative"#) -}
e3c2da125338450c94509e9b9892fa7e
  $fShowTetris4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Positive"#) -}
efa3b7e911f0a15464cd0d04839cd8c0
  $fShowTetris5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "tetrisPiece = "#) -}
5dd060b6b2f36f698e64df151b85f1b3
  $fShowTetris6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "tetrisType = "#) -}
378e7361ba64ce2090dec825d28bb62e
  $fShowTetrisPiece :: GHC.Show.Show Tetris.TetrisPiece
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tetris.TetrisPiece
                  Tetris.$fShowTetrisPiece_$cshowsPrec
                  Tetris.$fShowTetrisPiece_$cshow
                  Tetris.$fShowTetrisPiece_$cshowList -}
2f2b277786fd4b2668c74442e0334e80
  $fShowTetrisPiece1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TetrisPiece"#) -}
378e7361ba64ce2090dec825d28bb62e
  $fShowTetrisPiece_$cshow :: Tetris.TetrisPiece -> GHC.Base.String
  {- Arity: 1, Strictness: <S(SL),1*U(1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Tetris.TetrisPiece) ->
                 case w of ww { Tetris.TetrisPiece ww1 ww2 ->
                 Tetris.$w$cshow ww1 ww2 }) -}
378e7361ba64ce2090dec825d28bb62e
  $fShowTetrisPiece_$cshowList ::
    [Tetris.TetrisPiece] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ls :: [Tetris.TetrisPiece]) (s :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ Tetris.TetrisPiece
                   (Tetris.$fShowTetrisPiece_$cshowsPrec GHC.Show.shows22)
                   ls
                   s) -}
378e7361ba64ce2090dec825d28bb62e
  $fShowTetrisPiece_$cshowsPrec ::
    GHC.Types.Int -> Tetris.TetrisPiece -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S(SL),1*U(1*U,1*U)><L,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Tetris.TetrisPiece)
                   (w2 :: GHC.Base.String) ->
                 case w1 of ww { Tetris.TetrisPiece ww1 ww2 ->
                 Tetris.$w$cshowsPrec3 ww1 ww2 w2 }) -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fShowTetrisType :: GHC.Show.Show Tetris.TetrisType
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Tetris.TetrisType
                  Tetris.$fShowTetrisType_$cshowsPrec
                  Tetris.$fShowTetrisType_$cshow
                  Tetris.$fShowTetrisType_$cshowList -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fShowTetrisType1 :: Tetris.TetrisType -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Tetris.TetrisType) (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Tetris.Positive
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Tetris.$fShowTetris4)
                        eta
                   Tetris.Negative
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Tetris.$fShowTetris3)
                        eta }) -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fShowTetrisType_$cshow :: Tetris.TetrisType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Tetris.TetrisType) ->
                 case x1 of wild {
                   Tetris.Positive -> Tetris.$fShowTetris4
                   Tetris.Negative -> Tetris.$fShowTetris3 }) -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fShowTetrisType_$cshowList ::
    [Tetris.TetrisType] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Tetris.TetrisType
                   Tetris.$fShowTetrisType1) -}
1c4ac6aad6fd367176a72bfc6eea5218
  $fShowTetrisType_$cshowsPrec ::
    GHC.Types.Int -> Tetris.TetrisType -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Types.Int)
                   (ds1 :: Tetris.TetrisType)
                   (eta :: GHC.Base.String) ->
                 case ds1 of wild {
                   Tetris.Positive
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Tetris.$fShowTetris4)
                        eta
                   Tetris.Negative
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b
                           (c :: GHC.Types.Char -> b -> b)[OneShot]
                           (n :: b)[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Tetris.$fShowTetris3)
                        eta }) -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fShowTetris_$cshow :: Tetris.Tetris -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U(1*U(U),1*U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x1 :: Tetris.Tetris) ->
                 Tetris.$fShowTetris_$cshowsPrec
                   GHC.Show.shows22
                   x1
                   (GHC.Types.[] @ GHC.Types.Char)) -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fShowTetris_$cshowList :: [Tetris.Tetris] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Tetris.Tetris
                   Tetris.$fShowTetris1) -}
66f6dd4721eb85024dbe46bf1d55f7a5
  $fShowTetris_$cshowsPrec ::
    GHC.Types.Int -> Tetris.Tetris -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <S(S),1*U(U)><S,1*U(1*U,1*U(1*U(U),1*U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Types.Int)
                   (w1 :: Tetris.Tetris)
                   (w2 :: GHC.Base.String) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Tetris.Tetris ww3 ww4 ->
                 Tetris.$w$cshowsPrec2 ww1 ww3 ww4 w2 } }) -}
af37ca35d2e996774be37bcd1d0a4726
  $s$dmshowList1 ::
    Tetris.TetrisPiece -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (w :: Tetris.TetrisPiece)
                   (w1 :: GHC.Base.String)[OneShot] ->
                 case w of ww { Tetris.TetrisPiece ww1 ww2 ->
                 Tetris.$w$cshowsPrec3 ww1 ww2 w1 }) -}
fa87e4261145f9e13e981b0e7240e494
  $tc'Grid :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14905839033966701289##
                   7680029455472326511##
                   Tetris.$trModule
                   Tetris.$tc'Grid1) -}
55979a033e234e9e598e949753cb2b64
  $tc'Grid1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Grid"#) -}
e00dc31c8129545fb6d04dcc86f64fc7
  $tc'Negative :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8240199210790457214##
                   7760443091188954602##
                   Tetris.$trModule
                   Tetris.$tc'Negative1) -}
beed3c48fb90437f3efef40a5333db57
  $tc'Negative1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Negative"#) -}
92a6fdba6b63653a83f974fac108b1ea
  $tc'Point :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8852485350860152848##
                   10902782525277963159##
                   Tetris.$trModule
                   Tetris.$tc'Point1) -}
5cef181668450ad8f3a13db6f0d56554
  $tc'Point1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Point"#) -}
57655324aae041e8f0d7e25551b9e655
  $tc'PointOffset :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13358622977121318048##
                   11949347943250519724##
                   Tetris.$trModule
                   Tetris.$tc'PointOffset1) -}
cb0646709258e7be81a7b4c5f05ad05a
  $tc'PointOffset1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'PointOffset"#) -}
b1094f75ed39daec5f78a212e5aa2d57
  $tc'Positive :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10487603941882937015##
                   6701507601329574215##
                   Tetris.$trModule
                   Tetris.$tc'Positive1) -}
4d365dd0d2b7bfcc470c071557f6b1d4
  $tc'Positive1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Positive"#) -}
81e84dfb4488543c36e32617c9e855d7
  $tc'Tetris :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   18292932209198305093##
                   2511477165309611326##
                   Tetris.$trModule
                   Tetris.$tc'Tetris1) -}
cace9f92c39212f18b5bdbd78fcb4f99
  $tc'Tetris1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Tetris"#) -}
7de52a183aff6634a04ed1c5baf0eb2f
  $tc'TetrisPiece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9438005440816362596##
                   14618683899012839787##
                   Tetris.$trModule
                   Tetris.$tc'TetrisPiece1) -}
82bc73dbad8b7d93fca29810f95f6b9c
  $tc'TetrisPiece1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TetrisPiece"#) -}
dd73b0ad6fe225e3d43059f3ce66082a
  $tcGrid :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2652448142632343797##
                   4411869027973259603##
                   Tetris.$trModule
                   Tetris.$tcGrid1) -}
7e3ed4e49030bc3466b66495243fbb6d
  $tcGrid1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Grid"#) -}
74671bb40bf5b3f126e2246c269b188a
  $tcPoint :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15294278317836077294##
                   9908559256517164355##
                   Tetris.$trModule
                   Tetris.$tcPoint1) -}
76267d7fc4a179d9fa301c3e56f43685
  $tcPoint1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Point"#) -}
a98e5b76f0fdd6850defb5048e929f61
  $tcPointOffset :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11267438597514520111##
                   7985538909815253990##
                   Tetris.$trModule
                   Tetris.$tcPointOffset1) -}
e799bc9ac00364f3bf3b243f073e9dc8
  $tcPointOffset1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "PointOffset"#) -}
e0a86f726c2e0e3a9514b94c7e47e508
  $tcTetris :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14622035122596500416##
                   13599984510108420751##
                   Tetris.$trModule
                   Tetris.$trModule1) -}
029b793f732ca630f43c5352512e4dda
  $tcTetrisPiece :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15909277824799240717##
                   5907873675930538147##
                   Tetris.$trModule
                   Tetris.$tcTetrisPiece1) -}
4cd93204ea6bffa8a6ad8b554f4a7947
  $tcTetrisPiece1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TetrisPiece"#) -}
207bed25198653ac8347d33543c4f831
  $tcTetrisType :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   63142487500322232##
                   5235108976019992593##
                   Tetris.$trModule
                   Tetris.$tcTetrisType1) -}
a79f2af59c0a7e6944e7edbd0e8cdf4c
  $tcTetrisType1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TetrisType"#) -}
fa691e2105f47aa1288d303b5e57c84d
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Tetris.$trModule2
                   Tetris.$trModule1) -}
466e013d62afdbce13dbb008ca6d7521
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Tetris"#) -}
6863d7927aa3f9ebb829a2200942d2b4
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
3720784500c9429831d2db11f4c29810
  $w$c/= ::
    GHC.Classes.Eq a =>
    GHC.Prim.Int# -> [[a]] -> GHC.Prim.Int# -> [[a]] -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(C(C1(U)),A)><S,U><L,1*U><S,U><L,1*U>, Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Classes.Eq a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: [[a]])
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: [[a]]) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case GHC.Classes.$fEq[]_$c==
                             @ [a]
                             (GHC.Classes.$fEq[] @ a w)
                             ww1
                             ww3 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
afcdcb63dcba0a02845ff033f554f713
  $w$c/=1 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x1 ->
                      case ww3 of wild2 { GHC.Types.I# y1 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x1 y1) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
c421e2961ef430edbb4ddca7cc06a8e5
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,U><L,1*U(U)><S,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Prim.Int#)
                   (ww3 :: GHC.Types.Int) ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.eqInt ww1 ww3 }) -}
1bbc30388d7169b4a2aff923fa4232ad
  $w$c==1 ::
    Tetris.TetrisType
    -> Tetris.Grid GHC.Types.Bool
    -> Tetris.TetrisType
    -> Tetris.Grid GHC.Types.Bool
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(1*U(U),1*U)><S,1*U><L,1*U(1*U(U),1*U)>,
     Inline: [0],
     Unfolding: (\ (ww :: Tetris.TetrisType)
                   (ww1 :: Tetris.Grid GHC.Types.Bool)
                   (ww2 :: Tetris.TetrisType)
                   (ww3 :: Tetris.Grid GHC.Types.Bool) ->
                 let {
                   $j :: GHC.Prim.Void# -> GHC.Types.Bool
                     {- Arity: 1, Strictness: <L,A> -}
                   = \ (w :: GHC.Prim.Void#)[OneShot] ->
                     case ww1 of wild { Tetris.Grid a1 a2 ->
                     case ww3 of wild1 { Tetris.Grid b1 b2 ->
                     case a1 of wild2 { GHC.Types.I# x1 ->
                     case b1 of wild3 { GHC.Types.I# y1 ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.==# x1 y1) of wild4 {
                       GHC.Types.False -> GHC.Types.False
                       GHC.Types.True
                       -> GHC.Classes.$fEq[]_$c==
                            @ [GHC.Types.Bool]
                            Tetris.$fEqGrid_$s$fEq[]
                            a2
                            b2 } } } } }
                 } in
                 case ww of wild {
                   Tetris.Positive
                   -> case ww2 of wild1 {
                        Tetris.Positive -> $j GHC.Prim.void#
                        Tetris.Negative -> GHC.Types.False }
                   Tetris.Negative
                   -> case ww2 of wild1 {
                        Tetris.Positive -> GHC.Types.False
                        Tetris.Negative -> $j GHC.Prim.void# } }) -}
7441dab9fe0093201f13f11585409a70
  $w$cshow ::
    GHC.Base.Maybe Tetris.Point
    -> [Tetris.PointOffset] -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.Maybe Tetris.Point)
                   (ww1 :: [Tetris.PointOffset]) ->
                 case ww of wild {
                   GHC.Base.Nothing -> Tetris.$fShowTetrisPiece1
                   GHC.Base.Just originPoint
                   -> case originPoint of ww2 { Tetris.Point ww3 ww4 ->
                      case Tetris.$wgo ww1 ww3 ww4 of ww5 { (#,#) ww6 ww7 ->
                      Tetris.$w$cshowsPrec1
                        0#
                        ww6
                        ww7
                        (GHC.Types.[] @ GHC.Types.Char) } } }) -}
31825e8ff7c3b4f44ad8bdc2efce0dbf
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int#
    -> GHC.Types.Int -> [[a]] -> GHC.Base.String -> GHC.Base.String
  {- Arity: 5,
     Strictness: <L,1*U(A,A,1*C(C1(U)))><S,U><L,1*U(U)><L,1*U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: [[a]])
                   (w1 :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x1 :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Tetris.$fShowGrid6
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww4
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  Tetris.$fShowGrid5
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Tetris.$fShowGrid4
                                     (GHC.Show.showList__
                                        @ [a]
                                        (GHC.Show.showList @ a w)
                                        ww2
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           Tetris.$fShowGrid3
                                           x1)))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Tetris.$fShowGrid2 (g w1)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Tetris.$fShowGrid2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w1))) }) -}
a30ece48d7b0f6189ecb51bdbdddae43
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U(U)><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: GHC.Types.Int)
                   (w :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x1 :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Tetris.$fShowPoint4
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww4
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  Tetris.$fShowGrid5
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Tetris.$fShowPoint3
                                     (case ww2 of ww5 { GHC.Types.I# ww6 ->
                                      case GHC.Show.$wshowSignedInt
                                             0#
                                             ww6
                                             (GHC.Base.++
                                                @ GHC.Types.Char
                                                Tetris.$fShowGrid3
                                                x1) of ww7 { (#,#) ww8 ww9 ->
                                      GHC.Types.:
                                        @ GHC.Types.Char
                                        ww8
                                        ww9 } }))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Tetris.$fShowPoint2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Tetris.$fShowPoint2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w))) }) -}
80ef21720b5d8817bb725201992512a4
  $w$cshowsPrec2 ::
    GHC.Prim.Int#
    -> Tetris.TetrisType
    -> Tetris.Grid GHC.Types.Bool
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U><L,1*U(1*U(U),1*U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: Tetris.TetrisType)
                   (ww2 :: Tetris.Grid GHC.Types.Bool)
                   (w :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x1 :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Tetris.$fShowTetris6
                       (let {
                          g1 :: GHC.Base.String -> GHC.Base.String
                            {- Arity: 1, Strictness: <L,1*U> -}
                          = \ (x2 :: GHC.Base.String)[OneShot] ->
                            GHC.Base.++
                              @ GHC.Types.Char
                              Tetris.$fShowGrid5
                              (GHC.Base.++
                                 @ GHC.Types.Char
                                 Tetris.$fShowTetris5
                                 (case ww2 of ww3 { Tetris.Grid ww4 ww5 ->
                                  Tetris.$w$s$cshowsPrec
                                    0#
                                    ww4
                                    ww5
                                    (GHC.Base.++ @ GHC.Types.Char Tetris.$fShowGrid3 x2) }))
                        } in
                        case ww1 of wild {
                          Tetris.Positive
                          -> GHC.Base.++ @ GHC.Types.Char Tetris.$fShowTetris4 (g1 x1)
                          Tetris.Negative
                          -> GHC.Base.++ @ GHC.Types.Char Tetris.$fShowTetris3 (g1 x1) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Tetris.$fShowTetris2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Tetris.$fShowTetris2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w))) }) -}
33821bef11444c6a80ecf202f051bef1
  $w$cshowsPrec3 ::
    GHC.Base.Maybe Tetris.Point
    -> [Tetris.PointOffset] -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 3, Strictness: <S,1*U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Base.Maybe Tetris.Point)
                   (ww1 :: [Tetris.PointOffset])
                   (w :: GHC.Base.String) ->
                 case ww of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.++ @ GHC.Types.Char Tetris.$fShowTetrisPiece1 w
                   GHC.Base.Just originPoint
                   -> case originPoint of ww2 { Tetris.Point ww3 ww4 ->
                      case Tetris.$wgo ww1 ww3 ww4 of ww5 { (#,#) ww6 ww7 ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        (Tetris.$w$cshowsPrec1 0# ww6 ww7 (GHC.Types.[] @ GHC.Types.Char))
                        w } } }) -}
b841c1d17534cbf09609a1dcc37b23cc
  $w$s$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> [[GHC.Types.Bool]]
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 4, Strictness: <S,U><L,1*U(U)><L,1*U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Types.Int)
                   (ww2 :: [[GHC.Types.Bool]])
                   (w :: GHC.Base.String) ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x1 :: GHC.Base.String)[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Tetris.$fShowGrid6
                       (case ww1 of ww3 { GHC.Types.I# ww4 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww4
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  Tetris.$fShowGrid5
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Tetris.$fShowGrid4
                                     (let {
                                        s :: GHC.Base.String
                                        = GHC.Base.++ @ GHC.Types.Char Tetris.$fShowGrid3 x1
                                      } in
                                      case ww2 of wild {
                                        [] -> GHC.CString.unpackAppendCString# "[]"# s
                                        : x2 xs
                                        -> GHC.Types.:
                                             @ GHC.Types.Char
                                             GHC.Show.showList__2
                                             (GHC.Show.$fShowBool_$cshowList
                                                x2
                                                (let {
                                                   lvl27 :: [GHC.Types.Char]
                                                   = GHC.Types.:
                                                       @ GHC.Types.Char
                                                       GHC.Show.showList__1
                                                       s
                                                 } in
                                                 letrec {
                                                   showl :: [[GHC.Types.Bool]] -> GHC.Base.String
                                                     {- Arity: 1, Strictness: <S,1*U> -}
                                                   = \ (ds2 :: [[GHC.Types.Bool]]) ->
                                                     case ds2 of wild1 {
                                                       [] -> lvl27
                                                       : y1 ys
                                                       -> GHC.Types.:
                                                            @ GHC.Types.Char
                                                            GHC.Show.shows7
                                                            (GHC.Show.$fShowBool_$cshowList
                                                               y1
                                                               (showl ys)) }
                                                 } in
                                                 showl xs)) }))) of ww5 { (#,#) ww6 ww7 ->
                        GHC.Types.: @ GHC.Types.Char ww6 ww7 } })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> GHC.Base.++ @ GHC.Types.Char Tetris.$fShowGrid2 (g w)
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Tetris.$fShowGrid2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows6 w))) }) -}
56795c5cfec2f5fc4e3025e84ebe8a73
  $wgo ::
    [Tetris.PointOffset]
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U><L,U>,
     Inline: [0] -}
17bd4a3ec42b8635bff3b3f9cd156850
  data Grid a = Grid {gridSize :: GHC.Types.Int, gridData :: [[a]]}
85cd496138a5059b07114f34a9f8bbc6
  data Point = Point {x :: GHC.Types.Int, y :: GHC.Types.Int}
2523925dc029db951f470602c83578af
  data PointOffset
    = PointOffset {xOffset :: GHC.Types.Int -> GHC.Types.Int,
                   yOffset :: GHC.Types.Int -> GHC.Types.Int}
66f6dd4721eb85024dbe46bf1d55f7a5
  data Tetris
    = Tetris {tetrisType :: Tetris.TetrisType,
              tetrisPiece :: Tetris.Grid GHC.Types.Bool}
378e7361ba64ce2090dec825d28bb62e
  data TetrisPiece
    = TetrisPiece {origin :: GHC.Base.Maybe Tetris.Point,
                   offsets :: [Tetris.PointOffset]}
1c4ac6aad6fd367176a72bfc6eea5218
  data TetrisType = Positive | Negative
6ed548d765669ac0c119b84d736405b7
  applyOffset :: Tetris.Point -> Tetris.PointOffset -> Tetris.Point
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U,U)><S,1*U(1*C1(U),1*C1(U))>m,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Tetris.Point) (ds1 :: Tetris.PointOffset) ->
                 case ds of wild { Tetris.Point ds2 ds3 ->
                 case ds1 of wild1 { Tetris.PointOffset ds4 ds5 ->
                 Tetris.Point (ds4 ds2) (ds5 ds3) } }) -}
02a0aa130ad06b900920c54caf93cd80
  applyOffsets ::
    Tetris.Point -> [Tetris.PointOffset] -> Tetris.Point
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U(U,U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Tetris.Point) (w1 :: [Tetris.PointOffset]) ->
                 case w of ww { Tetris.Point ww1 ww2 ->
                 case Tetris.$wgo w1 ww1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Tetris.Point ww4 ww5 } }) -}
b6d84993f50e32f9cc0b61b2affe96d2
  gridData :: Tetris.Grid a -> [[a]]
  RecSel Left Tetris.Grid
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Tetris.Grid a) ->
                 case ds of wild { Tetris.Grid ds1 ds2 -> ds2 }) -}
01b1952d9e28e109f714d39066f727eb
  gridSize :: Tetris.Grid a -> GHC.Types.Int
  RecSel Left Tetris.Grid
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Tetris.Grid a) ->
                 case ds of wild { Tetris.Grid ds1 ds2 -> ds1 }) -}
02abeffa8a18ea156d27630bf5ab4928
  offsets :: Tetris.TetrisPiece -> [Tetris.PointOffset]
  RecSel Left Tetris.TetrisPiece
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.TetrisPiece) ->
                 case ds of wild { Tetris.TetrisPiece ds1 ds2 -> ds2 }) -}
026b4b268244071cee3f63893b92f4b4
  origin :: Tetris.TetrisPiece -> GHC.Base.Maybe Tetris.Point
  RecSel Left Tetris.TetrisPiece
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.TetrisPiece) ->
                 case ds of wild { Tetris.TetrisPiece ds1 ds2 -> ds1 }) -}
2140427ca7a956b259907f594795c688
  rotateClockwise :: Tetris.TetrisPiece -> Tetris.TetrisPiece
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (piece :: Tetris.TetrisPiece) ->
                 case piece of wild { Tetris.TetrisPiece ds ds1 ->
                 Tetris.TetrisPiece
                   ds
                   (GHC.Base.build
                      @ Tetris.PointOffset
                      (\ @ b1
                         (c :: Tetris.PointOffset -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ Tetris.PointOffset
                         @ b1
                         (GHC.Base.mapFB
                            @ Tetris.PointOffset
                            @ b1
                            @ Tetris.PointOffset
                            c
                            Tetris.rotateClockwise1)
                         n
                         ds1)) }) -}
362f7c2294774e49fa5cdb17c437380f
  rotateClockwise1 :: Tetris.PointOffset -> Tetris.PointOffset
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(C(U(U)),U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.PointOffset) ->
                 case ds of wild { Tetris.PointOffset ds1 ds2 ->
                 Tetris.PointOffset
                   ds2
                   (\ (x1 :: GHC.Types.Int) ->
                    case ds1 x1 of wild1 { GHC.Types.I# x2 ->
                    GHC.Types.I# (GHC.Prim.negateInt# x2) }) }) -}
375988b25e92f4a59989290eacbaae41
  tetrisPiece :: Tetris.Tetris -> Tetris.Grid GHC.Types.Bool
  RecSel Left Tetris.Tetris
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U,U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.Tetris) ->
                 case ds of wild { Tetris.Tetris ds1 ds2 -> ds2 }) -}
6852a3834af4e6379e618412f2cd549c
  tetrisType :: Tetris.Tetris -> Tetris.TetrisType
  RecSel Left Tetris.Tetris
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.Tetris) ->
                 case ds of wild { Tetris.Tetris ds1 ds2 -> ds1 }) -}
e430cba35266b543b4a9363a4760735d
  x :: Tetris.Point -> GHC.Types.Int
  RecSel Left Tetris.Point
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U(U),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.Point) ->
                 case ds of wild { Tetris.Point ds1 ds2 -> ds1 }) -}
6e5df8b330e9ffedb84c90d817f7add9
  xOffset :: Tetris.PointOffset -> GHC.Types.Int -> GHC.Types.Int
  RecSel Left Tetris.PointOffset
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.PointOffset) ->
                 case ds of wild { Tetris.PointOffset ds1 ds2 -> ds1 }) -}
af2ab06582de78f5af1c30822524fe4a
  y :: Tetris.Point -> GHC.Types.Int
  RecSel Left Tetris.Point
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.Point) ->
                 case ds of wild { Tetris.Point ds1 ds2 -> ds2 }) -}
558123a245ba78f91113859bde672115
  yOffset :: Tetris.PointOffset -> GHC.Types.Int -> GHC.Types.Int
  RecSel Left Tetris.PointOffset
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Tetris.PointOffset) ->
                 case ds of wild { Tetris.PointOffset ds1 ds2 -> ds2 }) -}
instance [safe] GHC.Classes.Eq [Tetris.Grid] = Tetris.$fEqGrid
instance [safe] GHC.Classes.Eq [Tetris.Point] = Tetris.$fEqPoint
instance [safe] GHC.Classes.Eq [Tetris.Tetris] = Tetris.$fEqTetris
instance [safe] GHC.Classes.Eq [Tetris.TetrisType]
  = Tetris.$fEqTetrisType
instance [safe] GHC.Show.Show [Tetris.Grid] = Tetris.$fShowGrid
instance [safe] GHC.Show.Show [Tetris.Point] = Tetris.$fShowPoint
instance [safe] GHC.Show.Show [Tetris.Tetris] = Tetris.$fShowTetris
instance [safe] GHC.Show.Show [Tetris.TetrisPiece]
  = Tetris.$fShowTetrisPiece
instance [safe] GHC.Show.Show [Tetris.TetrisType]
  = Tetris.$fShowTetrisType
"SPEC/Tetris $fEq[] @ Bool" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                       GHC.Types.Bool)
  GHC.Classes.$fEq[] @ GHC.Types.Bool $dEq = Tetris.$fEqGrid_$s$fEq[]
"SPEC/Tetris $fEq[]_$c/= @ Bool" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                            GHC.Types.Bool)
  GHC.Classes.$fEq[]_$c/= @ GHC.Types.Bool $dEq
  = Tetris.$fEqGrid_$s$fEq[]_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

